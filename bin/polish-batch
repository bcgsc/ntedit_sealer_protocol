#!/usr/bin/env python3

import sys
import os
import uuid
import base64
import argparse
from os.path import join, dirname, realpath, abspath, isfile, exists, splitext, basename
sys.path.append(join(realpath(dirname(__file__)), '../btllib/install/python'))
import btllib
import subprocess as sp
import threading
import time
import signal

RECORD_IDS_FILENAME = 'record_ids'
INPUT_PIPENAME = 'targeted_input'
CONFIRM_PIPENAME = 'targeted_confirm'

def get_cli_args():
  parser = argparse.ArgumentParser()
  parser.add_argument('to_polish')
  parser.add_argument('K', default='32 28 24 20')
  parser.add_argument('prefix')
  parser.add_argument('confirm_pipepath')
  parser.add_argument('bfs_dir')
  parser.add_argument('-t', '--threads', type=int, default=5)
  parser.add_argument('-v', '--verbose', action='store_true')

  args = parser.parse_args()
  args.to_polish = abspath(args.to_polish)

  return args

def get_random_name():
  return base64.urlsafe_b64encode(uuid.uuid4().bytes).rstrip(b'=').replace(b'-', b'').decode('ascii')

def start_watchdog():
  def watch_parent():
    while os.getppid() != 1:
      time.sleep(1)
    os.kill(os.getpid(), signal.SIGTERM)
  threading.Thread(target=watch_parent, daemon=True).start()

if __name__ == "__main__":
  args = get_cli_args()

  start_watchdog()
  
  with open(RECORD_IDS_FILENAME) as f, open(join(args.bfs_dir, f"{args.prefix}_{INPUT_PIPENAME}"), 'w') as f2:
    for line in f:
      f2.write(line)
  with open(join(args.bfs_dir, f"{args.prefix}_{CONFIRM_PIPENAME}")) as f: f.read()

  bfs = ""
  for k in args.K.split():
    bfs += join(args.bfs_dir, f"{args.prefix}_targeted_k{k}.bf") + " "

  polished_contig = f"{splitext(args.to_polish)[0]}.ntedited.prepd.sealer_scaffold.upper.fa"

  sealer_protocol_process = sp.run([ f""" \
    ntedit-sealer \
    seqs={args.to_polish} \
    bfs='{bfs}' \
    K='{args.K}' \
    t={args.threads} \
    {polished_contig} \
  """ ], shell=True, text=True, capture_output=True, check=True)

  for k in args.K.split():
    os.remove(join(args.bfs_dir, f"{args.prefix}_targeted_k{k}.bf"))

  if args.verbose:
    to_print = ""
    print_next_lines = 0
    for line in sealer_protocol_process.stderr.split('\n'):
      line = line.strip()
      if print_next_lines > 0:
        to_print += f"{line}"
        print_next_lines -= 1
        if print_next_lines == 0:
          to_print += ')\n'
        else:
          to_print += ', '
      elif "No start/goal kmer" in line:
        print_next_lines = 11
        to_print += f"({line}, "
      elif "Gaps closed = " in line:
        print_next_lines = 1
        to_print += f"{line} ("
    btllib.log_info(to_print)

  with open(args.confirm_pipepath, 'w') as f: f.write(str(1))